import { SpecificationInput } from '../models/specification-input';
import { JobResults } from '../models/job';
import { JiraConfig } from '../models/config';
import { normalizeInput } from './normalizer';
import { planScenarios } from './scenario-planner';
import { buildPrompt } from './prompt-builder';
import { invokeLLMWithFallback } from './llm-client-v2';
import { validateScenarios } from './validator';
import { formatForJira } from './jira-formatter';
import { saveGeneratedScenarios, saveNeedsReviewScenarios, saveMetadata } from '../storage/file-manager';
import { createContextLogger } from '../utils/logger';
import { GeneratedTestScenario } from '../models/test-scenario';

export async function executePipeline(
  input: SpecificationInput,
  jiraConfig: JiraConfig,
  jobId: string
): Promise<JobResults> {
  const contextLogger = createContextLogger({
    job_id: jobId,
    confluence_page_id: input.confluence_page_id,
    parent_jira_issue_id: input.metadata?.parent_jira_issue_id,
  });

  contextLogger.info('Pipeline execution started');

  const pipelineStartTime = Date.now();

  try {
    const step1Start = Date.now();
    contextLogger.info('Pipeline Step 1: Input normalization');
    const normalizedInput = await normalizeInput(input);
    const step1Duration = Date.now() - step1Start;
    contextLogger.info('Pipeline Step 1 completed', { duration_ms: step1Duration });

    const step2Start = Date.now();
    contextLogger.info('Pipeline Step 2: Scenario planning');
    const scenarioPlan = await planScenarios(normalizedInput, jobId);
    const step2Duration = Date.now() - step2Start;
    contextLogger.info('Pipeline Step 2 completed', {
      duration_ms: step2Duration,
      recommended_count: scenarioPlan.recommended_count,
      scenario_types: scenarioPlan.scenario_types.map(st => st.classification),
      test_repository_folder: scenarioPlan.test_repository_folder,
    });

    const step3Start = Date.now();
    contextLogger.info('Pipeline Step 3: LLM prompt preparation');
    const promptMessages = buildPrompt(normalizedInput, scenarioPlan);
    const step3Duration = Date.now() - step3Start;
    contextLogger.info('Pipeline Step 3 completed', { duration_ms: step3Duration });

    const step4Start = Date.now();
    contextLogger.info('Pipeline Step 4: LLM invocation with fallback');
    const llmResult = await invokeLLMWithFallback(promptMessages, normalizedInput, jobId);
    const step4Duration = Date.now() - step4Start;
    contextLogger.info('Pipeline Step 4 completed', {
      duration_ms: step4Duration,
      scenario_count: llmResult.finalScenarios.length,
      primary_attempt_success: llmResult.primaryAttempt.success,
      fallback_attempted: !!llmResult.fallbackAttempt,
      fallback_success: llmResult.fallbackAttempt?.success
    });

    if (llmResult.finalScenarios.length === 0) {
      contextLogger.warn('No scenarios generated by LLM (including fallback)');
      return {
        total_scenarios: 0,
        validated_scenarios: 0,
        needs_review_scenarios: 0,
        scenarios: [],
      };
    }

    const step5Start = Date.now();
    contextLogger.info('Pipeline Step 5: Output validation with fallback logic');

    // First validate primary attempt scenarios
    let primaryValidatedScenarios: GeneratedTestScenario[] = [];
    if (llmResult.primaryAttempt.scenarios.length > 0) {
      primaryValidatedScenarios = await validateScenarios(llmResult.primaryAttempt.scenarios, normalizedInput, jobId);
    }

    let fallbackValidatedScenarios: GeneratedTestScenario[] = [];
    let shouldUseFallback = false;

    // Check if we need to use fallback based on validation results
    const fallbackEnabled = process.env.VALIDATION_FALLBACK_ENABLED === 'true';
    const primaryNeedsReview = primaryValidatedScenarios.filter(s => s.validation_status === 'needs_review').length;
    const primaryValidated = primaryValidatedScenarios.filter(s => s.validation_status === 'validated').length;

    if (fallbackEnabled && llmResult.fallbackAttempt && llmResult.fallbackAttempt.scenarios.length > 0) {
      // Always validate fallback scenarios if they exist
      fallbackValidatedScenarios = await validateScenarios(llmResult.fallbackAttempt.scenarios, normalizedInput, jobId);

      const fallbackNeedsReview = fallbackValidatedScenarios.filter(s => s.validation_status === 'needs_review').length;
      const fallbackValidated = fallbackValidatedScenarios.filter(s => s.validation_status === 'validated').length;

      // Use fallback if:
      // 1. Primary has more needs_review than fallback, OR
      // 2. Primary has no validated scenarios but fallback does, OR
      // 3. Primary failed completely but fallback succeeded
      shouldUseFallback = (
        (primaryNeedsReview > fallbackNeedsReview) ||
        (primaryValidated === 0 && fallbackValidated > 0) ||
        (!llmResult.primaryAttempt.success && llmResult.fallbackAttempt.success)
      );

      contextLogger.info('Validation-triggered fallback decision', {
        primary_validated: primaryValidated,
        primary_needs_review: primaryNeedsReview,
        fallback_validated: fallbackValidated,
        fallback_needs_review: fallbackNeedsReview,
        use_fallback: shouldUseFallback
      });
    }

    // Choose the better set of scenarios
    const finalValidatedScenarios = shouldUseFallback ? fallbackValidatedScenarios : primaryValidatedScenarios;

    const step5Duration = Date.now() - step5Start;
    contextLogger.info('Pipeline Step 5 completed', {
      duration_ms: step5Duration,
      used_fallback: shouldUseFallback,
      final_scenario_count: finalValidatedScenarios.length
    });

    const validatedCount = finalValidatedScenarios.filter(s => s.validation_status === 'validated').length;
    const needsReviewCount = finalValidatedScenarios.filter(s => s.validation_status === 'needs_review').length;

    const validatedOnly = finalValidatedScenarios.filter(s => s.validation_status === 'validated');
    const needsReviewOnly = finalValidatedScenarios.filter(s => s.validation_status === 'needs_review');

    const confluencePageId = input.confluence_page_id || 'manual-input';

    if (validatedOnly.length > 0) {
      await saveGeneratedScenarios(confluencePageId, validatedOnly);
    }

    if (needsReviewOnly.length > 0) {
      await saveNeedsReviewScenarios(confluencePageId, needsReviewOnly);
    }

    await saveMetadata(confluencePageId, {
      timestamp: new Date().toISOString(),
      specification_version: input.confluence_version || '1',
      confluence_page_id: confluencePageId,
    });

    const step6Start = Date.now();
    contextLogger.info('Pipeline Step 6: Jira/TestFlo preparation');
    await formatForJira(finalValidatedScenarios, jiraConfig, confluencePageId, jobId);
    const step6Duration = Date.now() - step6Start;
    contextLogger.info('Pipeline Step 6 completed', { duration_ms: step6Duration });

    const pipelineDuration = Date.now() - pipelineStartTime;    contextLogger.info('Pipeline execution completed successfully', {
      total_duration_ms: pipelineDuration,
      total_scenarios: finalValidatedScenarios.length,
      validated: validatedCount,
      needs_review: needsReviewCount,
    });

    return {
      total_scenarios: finalValidatedScenarios.length,
      validated_scenarios: validatedCount,
      needs_review_scenarios: needsReviewCount,
      scenarios: finalValidatedScenarios,
    };
  } catch (error) {
    const pipelineDuration = Date.now() - pipelineStartTime;

    contextLogger.error('Pipeline execution failed', {
      error: (error as Error).message,
      stack: (error as Error).stack,
      duration_ms: pipelineDuration,
    });

    throw error;
  }
}
