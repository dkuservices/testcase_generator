import path from 'path';
import fs from 'fs/promises';
import { BatchSummary, ScenarioWithSource, DuplicateGroup } from '../models/batch-job';
import { GeneratedTestScenario } from '../models/test-scenario';

const SUMMARY_DIR = path.join(process.cwd(), 'data', 'batch_summaries');

export async function generateBatchSummary(
  batchJobId: string,
  pageIds: string[],
  uniqueScenarios: ScenarioWithSource[],
  moduleLevelScenarios: GeneratedTestScenario[],
  duplicateGroups: DuplicateGroup[],
  contextLogger: any
): Promise<BatchSummary> {
  contextLogger.info('Generating batch summary document');

  // Calculate coverage stats
  const allScenarios = uniqueScenarios.map(s => s.scenario);
  const coverageStats = {
    total_happy_path: allScenarios.filter(s => s.scenario_classification === 'happy_path').length,
    total_negative: allScenarios.filter(s => s.scenario_classification === 'negative').length,
    total_edge_case: allScenarios.filter(s => s.scenario_classification === 'edge_case').length,
    total_validated: allScenarios.filter(s => s.validation_status === 'validated').length,
    total_needs_review: allScenarios.filter(s => s.validation_status === 'needs_review').length,
  };

  // Extract feature list from test names
  const featureList = Array.from(
    new Set(allScenarios.map(s => s.test_name).slice(0, 20))
  );

  // Extract integration points from module-level tests
  const integrationPoints = moduleLevelScenarios.map(s => s.test_name);

  const moduleOverview = {
    feature_list: featureList,
    integration_points: integrationPoints,
    workflow_count: moduleLevelScenarios.length,
  };

  const summary: BatchSummary = {
    pages_processed: pageIds,
    coverage_stats: coverageStats,
    module_overview: moduleOverview,
    generated_at: new Date().toISOString(),
  };

  // Generate Markdown document
  await generateMarkdownSummary(
    batchJobId,
    summary,
    uniqueScenarios,
    moduleLevelScenarios,
    duplicateGroups
  );

  return summary;
}

async function generateMarkdownSummary(
  batchJobId: string,
  summary: BatchSummary,
  uniqueScenarios: ScenarioWithSource[],
  moduleLevelScenarios: GeneratedTestScenario[],
  duplicateGroups: DuplicateGroup[]
): Promise<void> {
  const markdown = `# Batch Test Generation Summary

**Batch Job ID:** ${batchJobId}
**Generated:** ${new Date(summary.generated_at).toLocaleString()}
**Total Pages Processed:** ${summary.pages_processed.length}

---

## Coverage Statistics

- **Total Scenarios (after deduplication):** ${uniqueScenarios.length}
- **Happy Path:** ${summary.coverage_stats.total_happy_path}
- **Negative Cases:** ${summary.coverage_stats.total_negative}
- **Edge Cases:** ${summary.coverage_stats.total_edge_case}
- **Validated:** ${summary.coverage_stats.total_validated}
- **Needs Review:** ${summary.coverage_stats.total_needs_review}

---

## Deduplication Results

- **Duplicate Groups Found:** ${duplicateGroups.length}
- **Total Duplicates Removed:** ${duplicateGroups.reduce((sum, g) => sum + g.duplicates.length, 0)}

### Top Duplicate Groups

${duplicateGroups.slice(0, 5).map((group, idx) => `
${idx + 1}. **${group.kept_scenario.scenario.test_name}** (similarity: ${(group.similarity_score * 100).toFixed(1)}%)
   - Kept from page: ${group.kept_scenario.source_page_id}
   - Removed ${group.duplicates.length} duplicate(s)
`).join('\n')}

---

## Module-Level Integration Tests

**Total Workflows Generated:** ${moduleLevelScenarios.length}

${moduleLevelScenarios.map((scenario, idx) => `
### ${idx + 1}. ${scenario.test_name}

- **Classification:** ${scenario.scenario_classification}
- **Priority:** ${scenario.priority}
- **Steps:** ${scenario.test_steps.length}
`).join('\n')}

---

## Pages Processed

${summary.pages_processed.map(pageId => `- ${pageId}`).join('\n')}

---

## Feature Coverage

Top features covered across all pages:

${summary.module_overview.feature_list.slice(0, 15).map(f => `- ${f}`).join('\n')}

---

*Generated by AI Orchestrator Module 4.1*
`;

  const filePath = path.join(SUMMARY_DIR, `${batchJobId}_summary.md`);
  await fs.writeFile(filePath, markdown, 'utf-8');
}
